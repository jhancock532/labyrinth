<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <!--All this code is copy pasted by hand.-->

  <title>alice.html</title>
  <meta name="description" content="The way in.">

  <style>
  canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    margin: 0;
    z-index: -1;
  }
  </style>
</head>

<body>
  <script src="js/p5.min.js"></script>
  <script src="js/p5.sound.min.js"></script>
  <script src="js/dat.gui.min.js"></script>

  <script>
  //// ---- DAT.GUI CODE ---- ////
  let params = { 
    circleStartSize: 1600, //works well for 2K fullscreen devices. Set this dynamically to cover screen on mouseClick? //Done
    animationSpeed: 4, //This is also set dynamically on mouseclick.
    animationSpeedDivisor: 200, //Smaller is faster.
    reset: function(){
      framesAnimated = 0;
      schwooping = false;
      background("white");
      cursor("pointer");
    },
    startFrequency: 1000,
    endFrequency: 150,
    amplitude: 0.1, //ramp up this amplitude as the circle gets smaller? Hard to hear the lower frequencies.
    click: {
      lifespan: 300,
      width: 60,
      fadeOutTime: 250,
      fadeOutSpeed: 40,
      numberOfDashes: 5,
      dashes: {
        maxAngle: 0.85,
        angleVariance: 0,
        yOffset: 16,
        yForceOffset: 100,
        spreadVariance: 1,
        baseForce: 3,
        forceVariance: 0.2,
        deceleration: 0.91,
        dashLength: 10,
        dashVariance: 2,
        strokeWeight: 3.5,
        strokeVariance: 0.5,
      },
    },
  }

  //What if leaving comments in the source code is the documentation for this art project?
  //That makes a lot of sense.

  let gui = new dat.GUI();
  dat.GUI.toggleHide();
  //Using dat.gui I can tweak to get the right feel quickly.

  let circleFolder = gui.addFolder("Circle");
  circleFolder.add(params, "animationSpeedDivisor", 1, 1000).name("Speed");

  let soundFolder = gui.addFolder("Sound");
  soundFolder.add(params, "startFrequency", 0, 2000).name("Start Freq.");
  soundFolder.add(params, "endFrequency", 0, 2000).name("End Freq.");
  soundFolder.add(params, "amplitude", 0, 1).name("Volume");

  let clickFolder = gui.addFolder("Click");

  clickFolder.add(params.click, 'lifespan', 1, 200, 1).name("Lifespan");
  clickFolder.add(params.click, 'fadeOutTime', 0, 200, 1).name("Fade Out Time");
  clickFolder.add(params.click, 'fadeOutSpeed', 0, 200, 1).name("Fade Out Speed");
  clickFolder.add(params.click, 'width', 0, 300, 1).name("Width");
  clickFolder.add(params.click, 'numberOfDashes', 1, 30, 1).name("No. Dashes");

  let dashesFolder = clickFolder.addFolder("Dashes");
  dashesFolder.add(params.click.dashes, 'maxAngle', 0, 2).name("Max Angle");
  dashesFolder.add(params.click.dashes, 'angleVariance', 0, 1).name("Angle Variance");
  dashesFolder.add(params.click.dashes, 'yOffset', 0, 40).name("Curve");
  dashesFolder.add(params.click.dashes, 'yForceOffset', 0, 200).name("Closeness");
  dashesFolder.add(params.click.dashes, 'spreadVariance', 0, 20).name("Spread Variance");

  dashesFolder.add(params.click.dashes, 'baseForce', 0, 6).name("Force");
  dashesFolder.add(params.click.dashes, 'forceVariance', 0, 4).name("Force Variance");
  dashesFolder.add(params.click.dashes, 'deceleration', 0, 1).name("Deceleration");
  dashesFolder.add(params.click.dashes, 'strokeWeight', 0, 10).name("Dash Weight");
  dashesFolder.add(params.click.dashes, 'strokeVariance', 0, 5).name("Weight Variance");
  dashesFolder.add(params.click.dashes, 'dashLength', 0, 20).name("Dash Length");
  dashesFolder.add(params.click.dashes, 'dashVariance', 0, 5).name("Length Variance");

  gui.add(params, "reset").name("Reset");

  //// ---- P5JS CODE ---- ////
  // - Documentation - https://p5js.org/reference/

  //Developing using p5.js, not having a clear goal beyond the exploration of one and zero
  //The most important thing I learned yesterday was to focus on what I enjoy
  //This is going to be awesome.

  let schwooping = false;
  let framesAnimated = 0;
  let clickHint;
  let osc;

  function setup(){
    createCanvas(windowWidth, windowHeight); 
    colorMode(HSB, 360, 100, 100, 1); 
    frameRate(60);
    
    cursor("pointer"); 
    
    //cursor - pointer ... The fundamental indicator of user interaction.
    //Deciding which cursor to display is very important.
    //Being greeted with a white screen, just seeing the pointer...
    //We're reminded of the internet context, the fundamentals of how we interact with this world.
    //We so easily take the cursor for granted. Cursor mindfulness practice anyone? Cursor roulette?
    
    osc = new p5.Oscillator('sine');

    clickHint = new ClickEffect(windowWidth / 2, windowHeight / 2);
    //A really simple visual cue to let the user know that something is happening.
    //I went for the explosion effect to mimic the sound of the mouseclick.
  }

  function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
  }

  function mousePressed(){
    if (framesAnimated == 0){
      background(0, 0, 0, 1);
      setCircleParameters(); //size and speed
      schwooping = true;
      
      cursor(AUTO);
      
      osc.start();
      osc.freq(params.startFrequency, 0); //The lower frequencies hit the heart in a raw and direct manner.
      osc.amp(params.amplitude, 0);
    }
  }

  function setCircleParameters(){
    let topLeft = dist(mouseX, mouseY, 0, 0);
    let topRight = dist(mouseX, mouseY, windowWidth, 0);
    let bottomLeft = dist(mouseX, mouseY, 0, windowHeight);
    let bottomRight = dist(mouseX, mouseY, windowWidth, windowHeight);
    
    let startSize = max(topLeft, topRight, bottomRight, bottomLeft);
    
    params.circleStartSize = startSize * 2;
    
    params.animationSpeed = startSize / params.animationSpeedDivisor;
  }

  function draw(){
    
    //All this code is live for anyone to steal and interact with.
    //Art created entirely on the internet, one small piece at a time.
    //It doesn't really follow the conventional artist, who paints for months in private
    //It's going to be difficult working like this.
    //I'll be being judged by the anonymous eyes of the Internet! O.O
    //Scary.
    
    if (schwooping){
      background(0, 0, 0, 1);
      
      let size = params.circleStartSize - framesAnimated * params.animationSpeed;
      let frequency = lerp(params.startFrequency, params.endFrequency, 1 - size / params.circleStartSize);
      
      osc.freq(frequency, 0);
      ellipse(mouseX, mouseY, size, size);
      
      if (size < 0){
        schwooping = false;
        osc.amp(0, 0.5);
        osc.freq(0, 0.5);
        background(0, 0, 0, 1);

        window.location.href = "falling.html";
      }
      
      framesAnimated += 1;
    } else {
      if (frameCount >= 142){
        //The average attention span for mobile users on Facebook
        //According to a dodgy source - https://muckrack.com/blog/2020/07/14/how-declining-attention-spans-impact-your-social-media
        clickHint.render();
      }
    }
  }

  class ClickEffect {
    //This effect was based on my original "Click!" motion graphics experiment
    //This was in turn inspired by scotty pilgrim and into the spiderverse

    constructor(startX, startY){
      this.xPosition = startX;
      this.yPosition = startY;
      this.lifeSpan = params.click.lifespan;
      this.dashes = this.generateDashes();
    }
    
    generateDashes() {
      let dashes = [];
      let dashXPosition = this.xPosition - params.click.width / 2;
      
      for (let i = 0; i < params.click.numberOfDashes; i++){
        let dashYPosition = this.yPosition - params.click.dashes.yOffset * this.parabolicMultiplier(i / (params.click.numberOfDashes - 1));
        
        dashes.push({
          length: params.click.dashes.dashLength + random(-params.click.dashes.dashVariance, params.click.dashes.dashVariance),
          x: dashXPosition,
          y: dashYPosition,
          rotation: lerp(-params.click.dashes.maxAngle, params.click.dashes.maxAngle, i / params.click.numberOfDashes) + random(-params.click.dashes.angleVariance, params.click.dashes.angleVariance),
          direction: this.findForceDirection(this.xPosition, dashXPosition, this.yPosition + params.click.dashes.yForceOffset, dashYPosition, params.click.dashes.spreadVariance),
          magnitude: params.click.dashes.baseForce + random(-params.click.dashes.forceVariance, params.click.dashes.forceVariance),
          weight: params.click.dashes.strokeWeight + random(-params.click.dashes.strokeVariance, params.click.dashes.strokeVariance),
        });
        
        dashXPosition += params.click.width / params.click.numberOfDashes;
      }
      
      return dashes;
    }
    
    drawDashes() {
      this.dashes.forEach((dash) => {
        push();
        translate(dash.x, dash.y);
        rotate(dash.rotation);
        
        stroke('black');
        if (this.lifeSpan < (params.click.fadeOutTime)){
          let opacity = 1 - ((params.click.fadeOutTime - this.lifeSpan) / params.click.fadeOutSpeed);
          let fillColour = 'rgba(0,0,0,'+ opacity +')';
          stroke(fillColour);
        }

        strokeWeight(dash.weight);
        
        line(0, 0, 0, dash.length);
        pop();
      });
    }
    
    moveDashes() {
      this.dashes.forEach((dash) => {
        dash.x -= (dash.direction.x * dash.magnitude);
        dash.y -= (dash.direction.y * dash.magnitude);
        dash.magnitude *= params.click.dashes.deceleration;
      });
    }
    
    resetDashes() {
      this.dashes = this.generateDashes(params.click.numberOfDashes);
      this.lifeSpan = params.click.lifespan;
    }
    
    render() {
      background('white');
      this.lifeSpan -= 1;
      this.moveDashes();
      this.drawDashes();
      if (this.lifeSpan < 0){
        this.resetDashes();
      }
    }
    
    //Accepts a value between 0 and 1, returns 1 at 0.5
    //Returns 0 at 0 and 1. A nice quadratic curve.
    //https://www.emathhelp.net/calculators/algebra-2/parabola-calculator/?ft=p3&p1x=0&p1y=0&p2x=0.5&p2y=1&p3x=1&p3y=0&p3dir=x&steps=on
    parabolicMultiplier(x){
      return (-4 * x * x) + 4 * x;
    }
    
    findForceDirection(x1, x2, y1, y2, variance){
      let vector = {x: x1 - x2 + random(variance), y: y1 - y2 + random(variance)};
      let length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
      vector.x = vector.x / length;
      vector.y = vector.y / length;
      return vector;
    }

  }
  </script>
</body>
</html>